{"name":"Algorithms","tagline":"study algorithms:design and analysis.","body":"###Algorithms test\r\n##1、[container_of](container_of/readme.txt)  \r\n`container_of`是一个宏，定义在[`kernel.h`]中：\r\n\r\n```\r\n/**\r\n * container_of - cast a member of a structure out to the containing structure\r\n * @ptr:\tthe pointer to the member.结构体的成员变量的指针。\r\n * @type:\tthe type of the container struct this is embedded in.结构体类型。\r\n * @member:\tthe name of the member within the struct.ptr对应的成员变量在结构体中的名称。\r\n *\r\n */\r\n#define container_of(ptr, type, member) ({\t\t\t\\\r\n\tconst typeof( ((type *)0)->member ) *__mptr = (ptr);\t\\\r\n\t(type *)( (char *)__mptr - offsetof(type,member) );})\r\n```\r\n\r\n功能是：根据ptr和member返回该ptr所在的结构体的指针地址。\r\n详解：\r\n* `const typeof( ((type *)0)->member ) *__mptr = (ptr);` typeof是gcc的C语言扩展保留字，用于变量声明；  \r\n   `(type *)0` 是把0强制转换成type型的指针;   \r\n   `((type *)0)->member` 指向type的成员变量;   \r\n   `typeof( ((type *)0)->member )` 是声明这种变量;     \r\n   `const typeof(((type *)0)->member) *__mptr = (ptr);`是声明一个常量指针__mptr，并且初始化为ptr.  \r\n* `(type *)( (char *)__mptr - offsetof(type,member) )`;   \r\n  `offsetof`是一个宏定义在[stddef.h]中：  \r\n    `#define offsetof(type, member) ((size_t) &((type *)0)->member)` //就是求成员变量相对于结构体的偏移量  \r\n  `(char *)__mptr - offsetof(type,member)` 就是把指向该成员变量的指针向前后退该成员变量的偏移量，就可以指向该结构体的起始地址，然后再强制转换一下，就ok了。\r\n  \r\n##2、[list](list/README.md)\r\n使用container_of实现一个双向循环队列。\r\n\r\n##3、[rbtree](rbtree/readme.txt)\r\n 红黑树的实现与测试：\r\n+ 1)文件rbtree.h是红黑树的定义与实现的文件\r\n其中节点格式为：\r\n\r\n```\r\ntypedef int key_t;      //key类型\r\ntypedef int data_t;     //数据类型\r\ntypedef enum color_t{   //rb数color\r\n    RED = 0,\r\n    BLACK = 1\r\n} color_t;\r\n\r\n//节点定义\r\ntypedef struct rb_node_t{\r\n    struct rb_node_t *left, *right, *parent; //三个指针\r\n    key_t key;      //key\r\n    data_t data;    //value\r\n    color_t color;  //locor\r\n} rb_node_t;\r\n文件中包含了函数：\r\n//函数声明：\r\nstatic rb_node_t* rb_new_node(key_t key, data_t data);                 //新建节点\r\nstatic rb_node_t* rb_rotate_left(rb_node_t* node, rb_node_t* root);    //左旋\r\nstatic rb_node_t* rb_rotate_right(rb_node_t* node, rb_node_t* root);   //右旋\r\nstatic rb_node_t* rb_search_parent(key_t key, rb_node_t* root, rb_node_t **parent);    //协助搜索节点\r\nrb_node_t* rb_search(key_t key, rb_node_t* root);               //搜索节点\r\nrb_node_t* rb_insert(key_t key, data_t data, rb_node_t* root);  //插入节点\r\nstatic rb_node_t* rb_insert_fixup(rb_node_t *node, rb_node_t *root);   //插入节点后修正\r\nrb_node_t* rb_erase(key_t key, rb_node_t *root);                //删除节点\r\nstatic rb_node_t* rb_erase_fixup(rb_node_t *child, rb_node_t *parent, rb_node_t *root);//删除节点后修正\r\n```\r\n\r\n+ 2)文件rbtree-test.h是测试程序\r\n先随即生成100个节点，然后插入并查询，再随即删除30个节点。\r\n\r\n##4、[字符串匹配](substring_search/readme.txt)\r\n* 蛮力方法 [brute_force.c](substring_search/brute_force.c)\r\n* kmp算法 [kmpsearch.c](substring_search/kmpsearch.c)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}