<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Algorithms : study algorithms:design and analysis.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Algorithms</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/gqqh/algorithms">View on GitHub</a>

          <h1 id="project_title">Algorithms</h1>
          <h2 id="project_tagline">study algorithms:design and analysis.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/gqqh/algorithms/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/gqqh/algorithms/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a name="algorithms-test" class="anchor" href="#algorithms-test"><span class="octicon octicon-link"></span></a>Algorithms test</h3>

<h2>
<a name="1container_of" class="anchor" href="#1container_of"><span class="octicon octicon-link"></span></a>1、<a href="container_of/readme.txt">container_of</a>
</h2>

<p><code>container_of</code>是一个宏，定义在[<code>kernel.h</code>]中：</p>

<pre><code>/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:    the pointer to the member.结构体的成员变量的指针。
 * @type:   the type of the container struct this is embedded in.结构体类型。
 * @member: the name of the member within the struct.ptr对应的成员变量在结构体中的名称。
 *
 */
#define container_of(ptr, type, member) ({          \
    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
    (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<p>功能是：根据ptr和member返回该ptr所在的结构体的指针地址。
详解：</p>

<ul>
<li>
<code>const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);</code> typeof是gcc的C语言扩展保留字，用于变量声明；<br><code>(type *)0</code> 是把0强制转换成type型的指针;<br><code>((type *)0)-&gt;member</code> 指向type的成员变量;<br><code>typeof( ((type *)0)-&gt;member )</code> 是声明这种变量;<br><code>const typeof(((type *)0)-&gt;member) *__mptr = (ptr);</code>是声明一个常量指针__mptr，并且初始化为ptr.<br>
</li>
<li>
<code>(type *)( (char *)__mptr - offsetof(type,member) )</code>;<br><code>offsetof</code>是一个宏定义在[stddef.h]中：<br><code>#define offsetof(type, member) ((size_t) &amp;((type *)0)-&gt;member)</code> //就是求成员变量相对于结构体的偏移量<br><code>(char *)__mptr - offsetof(type,member)</code> 就是把指向该成员变量的指针向前后退该成员变量的偏移量，就可以指向该结构体的起始地址，然后再强制转换一下，就ok了。</li>
</ul><h2>
<a name="2list" class="anchor" href="#2list"><span class="octicon octicon-link"></span></a>2、<a href="list/README.md">list</a>
</h2>

<p>使用container_of实现一个双向循环队列。</p>

<h2>
<a name="3rbtree" class="anchor" href="#3rbtree"><span class="octicon octicon-link"></span></a>3、<a href="rbtree/readme.txt">rbtree</a>
</h2>

<p>红黑树的实现与测试：</p>

<ul>
<li>1)文件rbtree.h是红黑树的定义与实现的文件
其中节点格式为：</li>
</ul><pre><code>typedef int key_t;      //key类型
typedef int data_t;     //数据类型
typedef enum color_t{   //rb数color
    RED = 0,
    BLACK = 1
} color_t;

//节点定义
typedef struct rb_node_t{
    struct rb_node_t *left, *right, *parent; //三个指针
    key_t key;      //key
    data_t data;    //value
    color_t color;  //locor
} rb_node_t;
文件中包含了函数：
//函数声明：
static rb_node_t* rb_new_node(key_t key, data_t data);                 //新建节点
static rb_node_t* rb_rotate_left(rb_node_t* node, rb_node_t* root);    //左旋
static rb_node_t* rb_rotate_right(rb_node_t* node, rb_node_t* root);   //右旋
static rb_node_t* rb_search_parent(key_t key, rb_node_t* root, rb_node_t **parent);    //协助搜索节点
rb_node_t* rb_search(key_t key, rb_node_t* root);               //搜索节点
rb_node_t* rb_insert(key_t key, data_t data, rb_node_t* root);  //插入节点
static rb_node_t* rb_insert_fixup(rb_node_t *node, rb_node_t *root);   //插入节点后修正
rb_node_t* rb_erase(key_t key, rb_node_t *root);                //删除节点
static rb_node_t* rb_erase_fixup(rb_node_t *child, rb_node_t *parent, rb_node_t *root);//删除节点后修正
</code></pre>

<ul>
<li>2)文件rbtree-test.h是测试程序
先随即生成100个节点，然后插入并查询，再随即删除30个节点。</li>
</ul><h2>
<a name="4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D" class="anchor" href="#4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="octicon octicon-link"></span></a>4、<a href="substring_search/readme.txt">字符串匹配</a>
</h2>

<ul>
<li>蛮力方法 <a href="substring_search/brute_force.c">brute_force.c</a>
</li>
<li>kmp算法 <a href="substring_search/kmpsearch.c">kmpsearch.c</a>
</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Algorithms maintained by <a href="https://github.com/gqqh">gqqh</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
